<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flowing Arcs</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #fff;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
        }
        canvas {
            display: block;
            cursor: default;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let draggedPoint = null;
        let hoveredPoint = null;
        const HANDLE_SIZE = 50;

        // Selection circle in upper right
        const selectionCircle = {
            getRadius() {
                return Math.min(canvas.width, canvas.height) * 0.15;
            },
            getX() {
                return canvas.width - this.getRadius() - 40;
            },
            getY() {
                return this.getRadius() + 40;
            },
            contains(x, y) {
                const dx = x - this.getX();
                const dy = y - this.getY();
                return Math.sqrt(dx * dx + dy * dy) <= this.getRadius();
            },
            draw() {
                const x = this.getX();
                const y = this.getY();
                const r = this.getRadius();

                // Draw circle background
                ctx.fillStyle = 'rgba(245, 245, 250, 0.9)';
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Label
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.font = '12px Courier New, monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('new gallery', x, y + r - 20);
            }
        };

        // Track which points are selected (inside the circle)
        const selectedPoints = new Set();

        class ControlPoint {
            constructor(xRatio, yRatio) {
                this.xRatio = xRatio;
                this.yRatio = yRatio;
                this.x = canvas.width * xRatio;
                this.y = canvas.height * yRatio;
            }

            updatePosition() {
                this.x = canvas.width * this.xRatio;
                this.y = canvas.height * this.yRatio;
            }

            draw(isHovered, isSelected = false) {
                const size = HANDLE_SIZE;

                if (isSelected) {
                    // Selected style - blue tint
                    ctx.fillStyle = 'rgba(220, 235, 255, 1)';
                    ctx.strokeStyle = isHovered ? 'rgba(50, 100, 200, 0.9)' : 'rgba(50, 100, 200, 0.6)';
                    ctx.lineWidth = isHovered ? 2 : 1.5;
                } else {
                    ctx.fillStyle = '#ffffff';
                    ctx.strokeStyle = isHovered ? 'rgba(0, 0, 0, 0.8)' : 'rgba(0, 0, 0, 0.4)';
                    ctx.lineWidth = isHovered ? 2 : 1;
                }

                ctx.fillRect(this.x - size/2, this.y - size/2, size, size);
                ctx.strokeRect(this.x - size/2, this.y - size/2, size, size);

                ctx.fillStyle = isSelected
                    ? 'rgba(50, 100, 200, 0.8)'
                    : (isHovered ? 'rgba(0, 0, 0, 0.9)' : 'rgba(0, 0, 0, 0.5)');
                ctx.font = '14px Courier New, monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('tag', this.x, this.y);
            }

            contains(mx, my) {
                const size = HANDLE_SIZE;
                return mx >= this.x - size/2 && mx <= this.x + size/2 &&
                       my >= this.y - size/2 && my <= this.y + size/2;
            }

            setPosition(x, y) {
                this.x = x;
                this.y = y;
                this.xRatio = x / canvas.width;
                this.yRatio = y / canvas.height;
            }
        }

        const controlPoints = [
            new ControlPoint(0.15, 0.25),
            new ControlPoint(0.5, 0.15),
            new ControlPoint(0.85, 0.3),
            new ControlPoint(0.25, 0.6),
            new ControlPoint(0.6, 0.55),
            new ControlPoint(0.8, 0.75),
            new ControlPoint(0.35, 0.85),
        ];

        class Curve {
            constructor(pointIndices) {
                this.pointIndices = pointIndices;
                this.pulsePhase = Math.random() * Math.PI * 2;
                this.pulseSpeed = 0.01 + Math.random() * 0.01;
            }

            update() {
                this.pulsePhase += this.pulseSpeed;
            }

            draw() {
                // Skip curves that include any selected points
                const hasSelectedPoint = this.pointIndices.some(i => selectedPoints.has(controlPoints[i]));
                if (hasSelectedPoint) return;

                const pulse = Math.sin(this.pulsePhase) * 0.5 + 0.5;
                const opacity = 0.15 + pulse * 0.65;
                const pts = this.pointIndices.map(i => controlPoints[i]);

                if (pts.length < 2) return;

                ctx.strokeStyle = `rgba(15, 15, 20, ${opacity})`;
                ctx.lineWidth = 1;
                ctx.lineCap = 'round';
                ctx.beginPath();

                if (pts.length === 2) {
                    ctx.moveTo(pts[0].x, pts[0].y);
                    ctx.lineTo(pts[1].x, pts[1].y);
                } else if (pts.length === 3) {
                    ctx.moveTo(pts[0].x, pts[0].y);
                    ctx.quadraticCurveTo(pts[1].x, pts[1].y, pts[2].x, pts[2].y);
                } else if (pts.length === 4) {
                    ctx.moveTo(pts[0].x, pts[0].y);
                    ctx.bezierCurveTo(pts[1].x, pts[1].y, pts[2].x, pts[2].y, pts[3].x, pts[3].y);
                } else {
                    ctx.moveTo(pts[0].x, pts[0].y);
                    for (let i = 0; i < pts.length - 1; i++) {
                        const p0 = pts[Math.max(0, i - 1)];
                        const p1 = pts[i];
                        const p2 = pts[Math.min(pts.length - 1, i + 1)];
                        const p3 = pts[Math.min(pts.length - 1, i + 2)];

                        const cp1x = p1.x + (p2.x - p0.x) / 6;
                        const cp1y = p1.y + (p2.y - p0.y) / 6;
                        const cp2x = p2.x - (p3.x - p1.x) / 6;
                        const cp2y = p2.y - (p3.y - p1.y) / 6;

                        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
                    }
                }
                ctx.stroke();
            }
        }

        const baseCurves = [
            new Curve([0, 1, 2]),
            new Curve([0, 3, 4, 2]),
            new Curve([3, 4, 5]),
            new Curve([1, 4, 6]),
            new Curve([0, 3, 6]),
            new Curve([2, 5, 6]),
            new Curve([1, 2, 5]),
            new Curve([0, 1, 4, 5]),
            new Curve([3, 1, 5, 6]),
            new Curve([0, 4, 2]),
            new Curve([3, 6, 5, 2]),
            new Curve([1, 3, 4, 5, 2]),
        ];

        // Offscreen dummy points for creating curves when few points remain
        function getDummyPoints() {
            return [
                { x: -100, y: canvas.height * 0.3 },
                { x: -100, y: canvas.height * 0.7 },
                { x: canvas.width + 100, y: canvas.height * 0.5 },
                { x: canvas.width * 0.5, y: -100 },
                { x: canvas.width * 0.3, y: canvas.height + 100 },
                { x: canvas.width * 0.7, y: canvas.height + 100 },
            ];
        }

        // Draw dynamic curves for unselected points - ensures each has multiple connections
        function drawDynamicCurves() {
            const unselected = controlPoints.filter(p => !selectedPoints.has(p));
            const time = Date.now() * 0.001;

            if (unselected.length === 0) return;

            ctx.lineWidth = 1;
            ctx.lineCap = 'round';

            // Always draw curves between all pairs of unselected points
            for (let i = 0; i < unselected.length; i++) {
                for (let j = i + 1; j < unselected.length; j++) {
                    const p1 = unselected[i];
                    const p2 = unselected[j];

                    // Draw multiple curved lines between each pair
                    for (let c = 0; c < 2; c++) {
                        const phase = time * (0.01 + c * 0.007) + i * 0.5 + j * 0.3;
                        const pulse = Math.sin(phase) * 0.5 + 0.5;
                        const opacity = 0.15 + pulse * 0.65;

                        const midX = (p1.x + p2.x) / 2;
                        const midY = (p1.y + p2.y) / 2;
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const perpX = -dy;
                        const perpY = dx;
                        const len = Math.sqrt(perpX * perpX + perpY * perpY) || 1;
                        const offset = (c === 0 ? 1 : -1) * (40 + c * 30);

                        const ctrlX = midX + (perpX / len) * offset;
                        const ctrlY = midY + (perpY / len) * offset;

                        ctx.strokeStyle = `rgba(15, 15, 20, ${opacity})`;
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.quadraticCurveTo(ctrlX, ctrlY, p2.x, p2.y);
                        ctx.stroke();
                    }
                }
            }

            // Draw curves to/from offscreen dummy points for each unselected point
            const dummies = getDummyPoints();
            unselected.forEach((p, pIdx) => {
                // Each point connects to 2-3 dummy points
                const numDummyConnections = 3;
                for (let d = 0; d < numDummyConnections; d++) {
                    const dummyIdx = (pIdx + d) % dummies.length;
                    const dummy = dummies[dummyIdx];

                    const phase = time * (0.008 + d * 0.004) + pIdx * 0.8 + d * 1.2;
                    const pulse = Math.sin(phase) * 0.5 + 0.5;
                    const opacity = 0.15 + pulse * 0.5;

                    // Use another dummy or midpoint as curve control
                    const ctrlDummy = dummies[(dummyIdx + 3) % dummies.length];
                    const ctrlX = (p.x + dummy.x + ctrlDummy.x) / 3;
                    const ctrlY = (p.y + dummy.y + ctrlDummy.y) / 3;

                    ctx.strokeStyle = `rgba(15, 15, 20, ${opacity})`;
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.quadraticCurveTo(ctrlX, ctrlY, dummy.x, dummy.y);
                    ctx.stroke();
                }
            });

            // If only one point, add self-connecting arcs
            if (unselected.length === 1) {
                const p = unselected[0];
                for (let i = 0; i < 3; i++) {
                    const phase = time * 0.5 + i * 0.7;
                    const pulse = Math.sin(phase) * 0.5 + 0.5;
                    const opacity = 0.15 + pulse * 0.65;

                    ctx.strokeStyle = `rgba(15, 15, 20, ${opacity})`;
                    const arcRadius = 40 + i * 25;
                    const rotation = i * Math.PI / 3;

                    ctx.beginPath();
                    ctx.arc(
                        p.x + Math.cos(rotation) * arcRadius * 0.3,
                        p.y + Math.sin(rotation) * arcRadius * 0.3 - arcRadius,
                        arcRadius,
                        0.2 * Math.PI + rotation * 0.3,
                        0.8 * Math.PI + rotation * 0.3
                    );
                    ctx.stroke();
                }
            }

            // Also draw original base curves when we have enough points
            if (unselected.length >= 4) {
                baseCurves.forEach(curve => {
                    curve.update();
                    curve.draw();
                });
            }
        }

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            controlPoints.forEach(p => p.updatePosition());
        });

        canvas.addEventListener('mousedown', (e) => {
            const mx = e.clientX;
            const my = e.clientY;

            for (const point of controlPoints) {
                if (point.contains(mx, my)) {
                    draggedPoint = point;
                    canvas.style.cursor = 'grabbing';
                    break;
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const mx = e.clientX;
            const my = e.clientY;

            if (draggedPoint) {
                draggedPoint.setPosition(mx, my);
            } else {
                hoveredPoint = null;
                for (const point of controlPoints) {
                    if (point.contains(mx, my)) {
                        hoveredPoint = point;
                        canvas.style.cursor = 'grab';
                        break;
                    }
                }
                if (!hoveredPoint) {
                    canvas.style.cursor = 'default';
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            draggedPoint = null;
            canvas.style.cursor = hoveredPoint ? 'grab' : 'default';
        });

        canvas.addEventListener('mouseleave', () => {
            draggedPoint = null;
            hoveredPoint = null;
            canvas.style.cursor = 'default';
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mx = touch.clientX;
            const my = touch.clientY;

            for (const point of controlPoints) {
                if (point.contains(mx, my)) {
                    draggedPoint = point;
                    break;
                }
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (draggedPoint) {
                const touch = e.touches[0];
                draggedPoint.setPosition(touch.clientX, touch.clientY);
            }
        }, { passive: false });

        canvas.addEventListener('touchend', () => {
            draggedPoint = null;
        });

        // Get dummy points for selected area - 270 degree arc above and to the right of circle
        // All points positioned offscreen
        function getSelectedDummyPoints() {
            const cx = selectionCircle.getX();
            const cy = selectionCircle.getY();

            // Position dummy points well offscreen
            return [
                { x: cx - 200, y: -150 },           // top-left, off top edge
                { x: cx, y: -150 },                  // top, off top edge
                { x: cx + 200, y: -150 },           // top-right, off top edge
                { x: canvas.width + 150, y: cy - 200 },  // right, off right edge
                { x: canvas.width + 150, y: cy },        // right, off right edge
                { x: canvas.width + 150, y: cy + 200 },  // right-bottom, off right edge
                { x: cx + 200, y: canvas.height + 150 }, // bottom, off bottom edge
            ];
        }

        // Draw curved connections between selected points
        function drawSelectedConnections() {
            const selected = Array.from(selectedPoints);
            if (selected.length < 1) return;

            const time = Date.now() * 0.001;
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';

            const cx = selectionCircle.getX();
            const cy = selectionCircle.getY();

            // Draw curves between selected points
            if (selected.length === 1) {
                // Single point - draw a self-connecting arc
                const p = selected[0];
                ctx.strokeStyle = 'rgba(50, 100, 200, 0.6)';
                const arcRadius = 30;
                ctx.beginPath();
                ctx.arc(p.x, p.y - arcRadius, arcRadius, 0.3 * Math.PI, 0.7 * Math.PI);
                ctx.stroke();
            } else {
                // Multiple points - draw curved lines between all pairs
                for (let i = 0; i < selected.length; i++) {
                    for (let j = i + 1; j < selected.length; j++) {
                        const p1 = selected[i];
                        const p2 = selected[j];

                        const midX = (p1.x + p2.x) / 2;
                        const midY = (p1.y + p2.y) / 2;

                        // Use perpendicular offset for more dramatic curves
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const perpX = -dy;
                        const perpY = dx;
                        const len = Math.sqrt(perpX * perpX + perpY * perpY) || 1;

                        const curveDirection = (i + j) % 2 === 0 ? 1 : -1;
                        const curveAmount = 60 + (i + j) * 20;

                        const ctrlX = midX + (perpX / len) * curveAmount * curveDirection;
                        const ctrlY = midY + (perpY / len) * curveAmount * curveDirection;

                        ctx.strokeStyle = 'rgba(50, 100, 200, 0.6)';
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.quadraticCurveTo(ctrlX, ctrlY, p2.x, p2.y);
                        ctx.stroke();
                    }
                }
            }

            // Draw curves to offscreen dummy points
            const dummies = getSelectedDummyPoints();
            selected.forEach((p, pIdx) => {
                // Each selected point connects to 2-3 dummy points
                const numConnections = 3;
                for (let d = 0; d < numConnections; d++) {
                    const dummyIdx = (pIdx * 2 + d) % dummies.length;
                    const dummy = dummies[dummyIdx];

                    const phase = time * (0.01 + d * 0.005) + pIdx * 0.6 + d * 0.9;
                    const pulse = Math.sin(phase) * 0.5 + 0.5;
                    const opacity = 0.3 + pulse * 0.4;

                    // Curve control point - much more curved
                    const midX = (p.x + dummy.x) / 2;
                    const midY = (p.y + dummy.y) / 2;

                    // Calculate perpendicular offset for more dramatic curves
                    const dx = dummy.x - p.x;
                    const dy = dummy.y - p.y;
                    const perpX = -dy;
                    const perpY = dx;
                    const len = Math.sqrt(perpX * perpX + perpY * perpY) || 1;

                    // Alternate curve direction and use larger offsets
                    const curveDirection = (pIdx + d) % 2 === 0 ? 1 : -1;
                    const curveAmount = 120 + d * 60;

                    const ctrlX = midX + (perpX / len) * curveAmount * curveDirection;
                    const ctrlY = midY + (perpY / len) * curveAmount * curveDirection;

                    ctx.strokeStyle = `rgba(50, 100, 200, ${opacity})`;
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.quadraticCurveTo(ctrlX, ctrlY, dummy.x, dummy.y);
                    ctx.stroke();
                }
            });
        }

        // Update which points are selected based on position
        function updateSelectedPoints() {
            for (const point of controlPoints) {
                if (selectionCircle.contains(point.x, point.y)) {
                    selectedPoints.add(point);
                } else {
                    selectedPoints.delete(point);
                }
            }
        }

        function animate() {
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update selection state
            updateSelectedPoints();

            // Draw selection circle first (background)
            selectionCircle.draw();

            // Draw dynamic curves for unselected points
            drawDynamicCurves();

            // Draw connections between selected points
            drawSelectedConnections();

            // Draw control points on top
            for (const point of controlPoints) {
                const isSelected = selectedPoints.has(point);
                point.draw(point === hoveredPoint || point === draggedPoint, isSelected);
            }

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
