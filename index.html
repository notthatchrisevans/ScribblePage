<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flowing Arcs</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #fff;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
        }
        canvas {
            display: block;
            cursor: default;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let draggedPoint = null;
        let hoveredPoint = null;
        const HANDLE_HEIGHT = 50;
        const HANDLE_WIDTH = HANDLE_HEIGHT * 2.5;

        // Selection circle in upper right
        const selectionCircle = {
            getRadius() {
                return Math.min(canvas.width, canvas.height) * 0.15;
            },
            getX() {
                return canvas.width - this.getRadius() - 40;
            },
            getY() {
                return this.getRadius() + 40;
            },
            contains(x, y) {
                const dx = x - this.getX();
                const dy = y - this.getY();
                return Math.sqrt(dx * dx + dy * dy) <= this.getRadius();
            },
            draw() {
                const x = this.getX();
                const y = this.getY();
                const r = this.getRadius();

                // Draw circle background
                ctx.fillStyle = 'rgba(245, 245, 250, 0.9)';
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Label
                const hasSelected = selectedPoints.size > 0;
                const labelY = y + r - 20;

                ctx.font = '12px Courier New, monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                if (hasSelected) {
                    // Draw button box around text
                    const textWidth = ctx.measureText('new gallery').width;
                    const padding = 8;
                    const boxWidth = textWidth + padding * 2;
                    const boxHeight = 20;

                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                    ctx.lineWidth = 1.5;
                    ctx.fillRect(x - boxWidth/2, labelY - boxHeight/2, boxWidth, boxHeight);
                    ctx.strokeRect(x - boxWidth/2, labelY - boxHeight/2, boxWidth, boxHeight);

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                } else {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                }

                ctx.fillText('new gallery', x, labelY);
            }
        };

        // Track which points are selected (inside the circle)
        const selectedPoints = new Set();

        // Particle system - free-floating particles affected by any tag
        const particles = [];
        const pendingParticles = [];

        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 0.08;
                this.vy = (Math.random() - 0.5) * 0.08;
                this.size = 37.5 + Math.random() * 75; // Spawn at 37.5 to 112.5
                this.growthRate = (Math.random() - 0.5) * 0.6; // Slower grow/shrink for longer life
                this.grey = Math.floor(230 + Math.random() * 25); // Light grey to almost white (230-255)
                this.dying = false; // Whether particle is fading out
                this.fadeIn = 0; // Fade in progress (0 to 1)
                this.fadeInSpeed = 0.002 + Math.random() * 0.003; // Very slow fade in
                this.hasBorder = Math.random() < 0.4; // 40% chance of having a border
                this.borderGrey = Math.max(0, this.grey - 20 - Math.random() * 15); // Slightly darker
            }

            update() {
                // Affected by all control points
                for (const point of controlPoints) {
                    const dx = point.x - this.x;
                    const dy = point.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 200 && dist > 0) {
                        // Stronger force, especially when close
                        const force = 0.8 / (dist * 0.05);
                        // Push away when close, slight pull when far
                        const pushPull = dist < 80 ? -1 : 0.15;
                        this.vx += (dx / dist) * force * pushPull;
                        this.vy += (dy / dist) * force * pushPull;
                    }
                }

                // Heavy damping - less movement
                this.vx *= 0.96;
                this.vy *= 0.96;

                // Very gentle random drift
                this.vx += (Math.random() - 0.5) * 0.008;
                this.vy += (Math.random() - 0.5) * 0.008;

                this.x += this.vx;
                this.y += this.vy;

                // Soft boundary - nudge back if going off screen
                if (this.x < 0) this.vx += 0.3;
                if (this.x > canvas.width) this.vx -= 0.3;
                if (this.y < 0) this.vy += 0.3;
                if (this.y > canvas.height) this.vy -= 0.3;

                // Fade in slowly
                if (this.fadeIn < 1) {
                    this.fadeIn += this.fadeInSpeed;
                    if (this.fadeIn > 1) this.fadeIn = 1;
                }

                // Size changes
                if (!this.dying) {
                    // Randomly adjust growth rate for organic feel
                    this.growthRate += (Math.random() - 0.5) * 0.15;
                    this.growthRate = Math.max(-0.9, Math.min(0.9, this.growthRate));
                    this.size += this.growthRate;

                    // Check for death conditions
                    if (this.size > 300) {
                        this.dying = true;
                        this.growthRate = 0.45 + Math.random() * 0.45; // Keep growing while dying
                    } else if (this.size < 75) {
                        this.dying = true;
                        this.growthRate = -0.3 - Math.random() * 0.3; // Keep shrinking while dying
                    }
                } else {
                    // Continue growing/shrinking while fading
                    this.size += this.growthRate;

                    // Dead when grown too big or shrunk to nothing
                    if (this.size > 450 || this.size <= 0) {
                        return false;
                    }
                }

                return true;
            }

            draw() {
                let alpha = 0.5;

                if (this.dying) {
                    if (this.growthRate > 0) {
                        // Growing and dying - fade based on size from 300 to 450
                        alpha = 0.5 * (1 - (this.size - 300) / 150);
                    } else {
                        // Shrinking and dying - fade based on size from 75 to 0
                        alpha = 0.5 * (this.size / 75);
                    }
                }

                // Apply fade in
                alpha *= this.fadeIn;

                alpha = Math.max(0, Math.min(0.5, alpha));

                const g = this.grey;
                const radius = Math.max(1, this.size);

                // Fill
                ctx.fillStyle = `rgba(${g}, ${g}, ${g}, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.fill();

                // Thin border for some particles
                if (this.hasBorder) {
                    const bg = this.borderGrey;
                    ctx.strokeStyle = `rgba(${bg}, ${bg}, ${bg}, ${alpha * 0.4})`;
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }
            }
        }

        // Randomly spawn dust motes across the screen
        function spawnRandomParticles() {
            // Target many more particles on screen
            const targetCount = 250;
            const currentCount = particles.length + pendingParticles.length;

            // Spawn multiple particles per frame when below target
            if (currentCount < targetCount) {
                const spawnChance = Math.random();
                const numToSpawn = spawnChance < 0.3 ? 2 : (spawnChance < 0.7 ? 1 : 0);

                for (let i = 0; i < numToSpawn; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const delay = Math.floor(Math.random() * 20);
                    pendingParticles.push({ x, y, delay });
                }
            }
        }

        function updateAndDrawParticles() {
            // Spawn new random particles
            spawnRandomParticles();

            // Process pending particles
            for (let i = pendingParticles.length - 1; i >= 0; i--) {
                const pending = pendingParticles[i];
                pending.delay--;
                if (pending.delay <= 0) {
                    particles.push(new Particle(pending.x, pending.y));
                    pendingParticles.splice(i, 1);
                }
            }

            // Update and draw active particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.draw();
                if (!p.update()) {
                    particles.splice(i, 1);
                }
            }
        }

        // Generate a random vibrant color
        function randomColor() {
            const hue = Math.floor(Math.random() * 360);
            return {
                hue: hue,
                fill: `hsla(${hue}, 70%, 85%, 1)`,
                stroke: `hsla(${hue}, 70%, 45%, 0.8)`,
                text: `hsla(${hue}, 70%, 35%, 0.9)`,
                line: `hsla(${(hue + 180) % 360}, 60%, 50%, 0.6)` // Complementary color for lines
            };
        }

        class ControlPoint {
            constructor(xRatio, yRatio) {
                this.xRatio = xRatio;
                this.yRatio = yRatio;
                this.x = canvas.width * xRatio;
                this.y = canvas.height * yRatio;
                this.selectedColor = null;
            }

            updatePosition() {
                this.x = canvas.width * this.xRatio;
                this.y = canvas.height * this.yRatio;
            }

            draw(isHovered, isSelected = false) {
                const w = HANDLE_WIDTH;
                const h = HANDLE_HEIGHT;

                ctx.fillStyle = '#ffffff';

                if (isSelected && this.selectedColor) {
                    // Selected style - white fill, colored border
                    ctx.strokeStyle = this.selectedColor.stroke;
                    ctx.lineWidth = isHovered ? 2 : 1.5;
                } else {
                    ctx.strokeStyle = isHovered ? 'rgba(0, 0, 0, 0.8)' : 'rgba(0, 0, 0, 0.4)';
                    ctx.lineWidth = isHovered ? 2 : 1;
                }

                ctx.fillRect(this.x - w/2, this.y - h/2, w, h);
                ctx.strokeRect(this.x - w/2, this.y - h/2, w, h);

                ctx.fillStyle = (isSelected && this.selectedColor)
                    ? this.selectedColor.text
                    : (isHovered ? 'rgba(0, 0, 0, 0.9)' : 'rgba(0, 0, 0, 0.5)');
                ctx.font = '14px Courier New, monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('tag', this.x, this.y);
            }

            contains(mx, my) {
                const w = HANDLE_WIDTH;
                const h = HANDLE_HEIGHT;
                return mx >= this.x - w/2 && mx <= this.x + w/2 &&
                       my >= this.y - h/2 && my <= this.y + h/2;
            }

            setPosition(x, y) {
                this.x = x;
                this.y = y;
                this.xRatio = x / canvas.width;
                this.yRatio = y / canvas.height;
            }
        }

        const controlPoints = [
            new ControlPoint(0.15, 0.25),
            new ControlPoint(0.5, 0.15),
            new ControlPoint(0.85, 0.3),
            new ControlPoint(0.25, 0.6),
            new ControlPoint(0.6, 0.55),
            new ControlPoint(0.8, 0.75),
            new ControlPoint(0.35, 0.85),
        ];

        class Curve {
            constructor(pointIndices) {
                this.pointIndices = pointIndices;
                this.pulsePhase = Math.random() * Math.PI * 2;
                this.pulseSpeed = 0.01 + Math.random() * 0.01;
            }

            update() {
                this.pulsePhase += this.pulseSpeed;
            }

            draw() {
                // Skip curves that include any selected points
                const hasSelectedPoint = this.pointIndices.some(i => selectedPoints.has(controlPoints[i]));
                if (hasSelectedPoint) return;

                const pulse = Math.sin(this.pulsePhase) * 0.5 + 0.5;
                const opacity = 0.15 + pulse * 0.65;
                const pts = this.pointIndices.map(i => controlPoints[i]);

                if (pts.length < 2) return;

                ctx.strokeStyle = `rgba(15, 15, 20, ${opacity})`;
                ctx.lineWidth = 1;
                ctx.lineCap = 'round';
                ctx.beginPath();

                if (pts.length === 2) {
                    ctx.moveTo(pts[0].x, pts[0].y);
                    ctx.lineTo(pts[1].x, pts[1].y);
                } else if (pts.length === 3) {
                    ctx.moveTo(pts[0].x, pts[0].y);
                    ctx.quadraticCurveTo(pts[1].x, pts[1].y, pts[2].x, pts[2].y);
                } else if (pts.length === 4) {
                    ctx.moveTo(pts[0].x, pts[0].y);
                    ctx.bezierCurveTo(pts[1].x, pts[1].y, pts[2].x, pts[2].y, pts[3].x, pts[3].y);
                } else {
                    ctx.moveTo(pts[0].x, pts[0].y);
                    for (let i = 0; i < pts.length - 1; i++) {
                        const p0 = pts[Math.max(0, i - 1)];
                        const p1 = pts[i];
                        const p2 = pts[Math.min(pts.length - 1, i + 1)];
                        const p3 = pts[Math.min(pts.length - 1, i + 2)];

                        const cp1x = p1.x + (p2.x - p0.x) / 6;
                        const cp1y = p1.y + (p2.y - p0.y) / 6;
                        const cp2x = p2.x - (p3.x - p1.x) / 6;
                        const cp2y = p2.y - (p3.y - p1.y) / 6;

                        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
                    }
                }
                ctx.stroke();
            }
        }

        const baseCurves = [
            new Curve([0, 1, 2]),
            new Curve([0, 3, 4, 2]),
            new Curve([3, 4, 5]),
            new Curve([1, 4, 6]),
            new Curve([0, 3, 6]),
            new Curve([2, 5, 6]),
            new Curve([1, 2, 5]),
            new Curve([0, 1, 4, 5]),
            new Curve([3, 1, 5, 6]),
            new Curve([0, 4, 2]),
            new Curve([3, 6, 5, 2]),
            new Curve([1, 3, 4, 5, 2]),
        ];

        // Offscreen dummy points for creating curves when few points remain
        function getDummyPoints() {
            return [
                { x: -100, y: canvas.height * 0.3 },
                { x: -100, y: canvas.height * 0.7 },
                { x: canvas.width + 100, y: canvas.height * 0.5 },
                { x: canvas.width * 0.5, y: -100 },
                { x: canvas.width * 0.3, y: canvas.height + 100 },
                { x: canvas.width * 0.7, y: canvas.height + 100 },
            ];
        }

        // Draw dynamic curves for unselected points - ensures each has multiple connections
        function drawDynamicCurves() {
            const unselected = controlPoints.filter(p => !selectedPoints.has(p));
            const time = Date.now() * 0.001;

            if (unselected.length === 0) return;

            ctx.lineWidth = 1;
            ctx.lineCap = 'round';

            // Always draw curves between all pairs of unselected points
            for (let i = 0; i < unselected.length; i++) {
                for (let j = i + 1; j < unselected.length; j++) {
                    const p1 = unselected[i];
                    const p2 = unselected[j];

                    // Draw multiple curved lines between each pair
                    for (let c = 0; c < 2; c++) {
                        const phase = time * (0.01 + c * 0.007) + i * 0.5 + j * 0.3;
                        const pulse = Math.sin(phase) * 0.5 + 0.5;
                        const opacity = 0.15 + pulse * 0.65;

                        const midX = (p1.x + p2.x) / 2;
                        const midY = (p1.y + p2.y) / 2;
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const perpX = -dy;
                        const perpY = dx;
                        const len = Math.sqrt(perpX * perpX + perpY * perpY) || 1;
                        const offset = (c === 0 ? 1 : -1) * (40 + c * 30);

                        const ctrlX = midX + (perpX / len) * offset;
                        const ctrlY = midY + (perpY / len) * offset;

                        ctx.strokeStyle = `rgba(15, 15, 20, ${opacity})`;
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.quadraticCurveTo(ctrlX, ctrlY, p2.x, p2.y);
                        ctx.stroke();
                    }
                }
            }

            // Draw curves to/from offscreen dummy points for each unselected point
            const dummies = getDummyPoints();
            unselected.forEach((p, pIdx) => {
                // Each point connects to 2-3 dummy points
                const numDummyConnections = 3;
                for (let d = 0; d < numDummyConnections; d++) {
                    const dummyIdx = (pIdx + d) % dummies.length;
                    const dummy = dummies[dummyIdx];

                    const phase = time * (0.008 + d * 0.004) + pIdx * 0.8 + d * 1.2;
                    const pulse = Math.sin(phase) * 0.5 + 0.5;
                    const opacity = 0.15 + pulse * 0.5;

                    // Use another dummy or midpoint as curve control
                    const ctrlDummy = dummies[(dummyIdx + 3) % dummies.length];
                    const ctrlX = (p.x + dummy.x + ctrlDummy.x) / 3;
                    const ctrlY = (p.y + dummy.y + ctrlDummy.y) / 3;

                    ctx.strokeStyle = `rgba(15, 15, 20, ${opacity})`;
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.quadraticCurveTo(ctrlX, ctrlY, dummy.x, dummy.y);
                    ctx.stroke();
                }
            });

            // If only one point, add self-connecting arcs
            if (unselected.length === 1) {
                const p = unselected[0];
                for (let i = 0; i < 3; i++) {
                    const phase = time * 0.5 + i * 0.7;
                    const pulse = Math.sin(phase) * 0.5 + 0.5;
                    const opacity = 0.15 + pulse * 0.65;

                    ctx.strokeStyle = `rgba(15, 15, 20, ${opacity})`;
                    const arcRadius = 40 + i * 25;
                    const rotation = i * Math.PI / 3;

                    ctx.beginPath();
                    ctx.arc(
                        p.x + Math.cos(rotation) * arcRadius * 0.3,
                        p.y + Math.sin(rotation) * arcRadius * 0.3 - arcRadius,
                        arcRadius,
                        0.2 * Math.PI + rotation * 0.3,
                        0.8 * Math.PI + rotation * 0.3
                    );
                    ctx.stroke();
                }
            }

            // Also draw original base curves when we have enough points
            if (unselected.length >= 4) {
                baseCurves.forEach(curve => {
                    curve.update();
                    curve.draw();
                });
            }
        }

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            controlPoints.forEach(p => p.updatePosition());
        });

        canvas.addEventListener('mousedown', (e) => {
            const mx = e.clientX;
            const my = e.clientY;

            for (const point of controlPoints) {
                if (point.contains(mx, my)) {
                    draggedPoint = point;
                    canvas.style.cursor = 'grabbing';
                    break;
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const mx = e.clientX;
            const my = e.clientY;

            if (draggedPoint) {
                draggedPoint.setPosition(mx, my);
            } else {
                hoveredPoint = null;
                for (const point of controlPoints) {
                    if (point.contains(mx, my)) {
                        hoveredPoint = point;
                        canvas.style.cursor = 'grab';
                        break;
                    }
                }
                if (!hoveredPoint) {
                    canvas.style.cursor = 'default';
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            draggedPoint = null;
            canvas.style.cursor = hoveredPoint ? 'grab' : 'default';
        });

        canvas.addEventListener('mouseleave', () => {
            draggedPoint = null;
            hoveredPoint = null;
            canvas.style.cursor = 'default';
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mx = touch.clientX;
            const my = touch.clientY;

            for (const point of controlPoints) {
                if (point.contains(mx, my)) {
                    draggedPoint = point;
                    break;
                }
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (draggedPoint) {
                const touch = e.touches[0];
                draggedPoint.setPosition(touch.clientX, touch.clientY);
            }
        }, { passive: false });

        canvas.addEventListener('touchend', () => {
            draggedPoint = null;
        });

        // Get dummy points for selected area - 270 degree arc above and to the right of circle
        // All points positioned offscreen
        function getSelectedDummyPoints() {
            const cx = selectionCircle.getX();
            const cy = selectionCircle.getY();

            // Position dummy points well offscreen
            return [
                { x: cx - 200, y: -150 },           // top-left, off top edge
                { x: cx, y: -150 },                  // top, off top edge
                { x: cx + 200, y: -150 },           // top-right, off top edge
                { x: canvas.width + 150, y: cy - 200 },  // right, off right edge
                { x: canvas.width + 150, y: cy },        // right, off right edge
                { x: canvas.width + 150, y: cy + 200 },  // right-bottom, off right edge
                { x: cx + 200, y: canvas.height + 150 }, // bottom, off bottom edge
            ];
        }

        // Draw curved connections between selected points
        function drawSelectedConnections() {
            const selected = Array.from(selectedPoints);
            if (selected.length < 1) return;

            const time = Date.now() * 0.001;
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';

            const cx = selectionCircle.getX();
            const cy = selectionCircle.getY();

            // Draw curves between selected points
            if (selected.length === 1) {
                // Single point - draw a self-connecting arc
                const p = selected[0];
                ctx.strokeStyle = p.selectedColor ? p.selectedColor.line : 'rgba(50, 100, 200, 0.6)';
                const arcRadius = 30;
                ctx.beginPath();
                ctx.arc(p.x, p.y - arcRadius, arcRadius, 0.3 * Math.PI, 0.7 * Math.PI);
                ctx.stroke();
            } else {
                // Multiple points - draw curved lines between all pairs
                for (let i = 0; i < selected.length; i++) {
                    for (let j = i + 1; j < selected.length; j++) {
                        const p1 = selected[i];
                        const p2 = selected[j];

                        const midX = (p1.x + p2.x) / 2;
                        const midY = (p1.y + p2.y) / 2;

                        // Use perpendicular offset for more dramatic curves
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const perpX = -dy;
                        const perpY = dx;
                        const len = Math.sqrt(perpX * perpX + perpY * perpY) || 1;

                        const curveDirection = (i + j) % 2 === 0 ? 1 : -1;
                        const curveAmount = 60 + (i + j) * 20;

                        const ctrlX = midX + (perpX / len) * curveAmount * curveDirection;
                        const ctrlY = midY + (perpY / len) * curveAmount * curveDirection;

                        // Use line color from first point
                        ctx.strokeStyle = p1.selectedColor ? p1.selectedColor.line : 'rgba(50, 100, 200, 0.6)';
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.quadraticCurveTo(ctrlX, ctrlY, p2.x, p2.y);
                        ctx.stroke();
                    }
                }
            }

            // Draw curves to offscreen dummy points
            const dummies = getSelectedDummyPoints();
            selected.forEach((p, pIdx) => {
                // Each selected point connects to 2-3 dummy points
                const numConnections = 3;
                for (let d = 0; d < numConnections; d++) {
                    const dummyIdx = (pIdx * 2 + d) % dummies.length;
                    const dummy = dummies[dummyIdx];

                    const phase = time * (0.01 + d * 0.005) + pIdx * 0.6 + d * 0.9;
                    const pulse = Math.sin(phase) * 0.5 + 0.5;
                    const opacity = 0.3 + pulse * 0.4;

                    // Curve control point - much more curved
                    const midX = (p.x + dummy.x) / 2;
                    const midY = (p.y + dummy.y) / 2;

                    // Calculate perpendicular offset for more dramatic curves
                    const dx = dummy.x - p.x;
                    const dy = dummy.y - p.y;
                    const perpX = -dy;
                    const perpY = dx;
                    const len = Math.sqrt(perpX * perpX + perpY * perpY) || 1;

                    // Alternate curve direction and use larger offsets
                    const curveDirection = (pIdx + d) % 2 === 0 ? 1 : -1;
                    const curveAmount = 120 + d * 60;

                    const ctrlX = midX + (perpX / len) * curveAmount * curveDirection;
                    const ctrlY = midY + (perpY / len) * curveAmount * curveDirection;

                    // Use line color from point with pulsing opacity
                    if (p.selectedColor) {
                        const hue = (p.selectedColor.hue + 180) % 360;
                        ctx.strokeStyle = `hsla(${hue}, 60%, 50%, ${opacity})`;
                    } else {
                        ctx.strokeStyle = `rgba(50, 100, 200, ${opacity})`;
                    }
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.quadraticCurveTo(ctrlX, ctrlY, dummy.x, dummy.y);
                    ctx.stroke();
                }
            });
        }

        // Update which points are selected based on position
        function updateSelectedPoints() {
            for (const point of controlPoints) {
                if (selectionCircle.contains(point.x, point.y)) {
                    if (!selectedPoints.has(point)) {
                        // Entering circle - assign random color
                        point.selectedColor = randomColor();
                        selectedPoints.add(point);
                    }
                } else {
                    if (selectedPoints.has(point)) {
                        // Leaving circle - clear color
                        point.selectedColor = null;
                        selectedPoints.delete(point);
                    }
                }
            }
        }

        function animate() {
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update selection state
            updateSelectedPoints();

            // Draw particles behind everything
            updateAndDrawParticles();

            // Draw selection circle
            selectionCircle.draw();

            // Draw dynamic curves for unselected points
            drawDynamicCurves();

            // Draw connections between selected points
            drawSelectedConnections();

            // Draw control points on top
            for (const point of controlPoints) {
                const isSelected = selectedPoints.has(point);
                point.draw(point === hoveredPoint || point === draggedPoint, isSelected);
            }

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
