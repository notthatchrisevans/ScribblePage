<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flowing Arcs</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
        }
        canvas {
            display: block;
            cursor: default;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let draggedPoint = null;
        let hoveredPoint = null;
        const HANDLE_HEIGHT = 50;
        const HANDLE_WIDTH = HANDLE_HEIGHT * 2.5;

        // Gallery configuration
        // Use file:// protocol for local testing, or serve via local web server
        const GALLERY_PATH = 'file:///D:/Web/Gallaries/Test/AndyGallary/';
        const GALLERY_HEIGHT = 120; // Height of image strip
        const GALLERY_MARGIN = 20; // Margin from bottom
        const IMAGE_GAP = 10; // Gap between images
        const SELECTION_BOX_PADDING = 6; // Padding around selected image

        // Sample tags for images (in real app, would come from EXIF or manifest)
        const sampleTags = [
            ['street', 'urban', 'night'],
            ['portrait', 'studio'],
            ['landscape', 'nature', 'mountains'],
            ['architecture', 'modern'],
            ['candid', 'people'],
            ['abstract', 'texture'],
            ['travel', 'city'],
            ['black-and-white', 'mood'],
            ['documentary', 'story'],
            ['minimal', 'clean'],
        ];

        // Gallery images data
        const galleryImages = [
            { file: 'DSCF0427.jpg', tags: ['street', 'urban'] },
            { file: 'DSCF1626.jpg', tags: ['portrait', 'candid'] },
            { file: 'L1000314.jpg', tags: ['landscape', 'nature'] },
            { file: 'L1000362.jpg', tags: ['architecture', 'city'] },
            { file: 'L1000437.jpg', tags: ['street', 'night'] },
            { file: 'L1000516.jpg', tags: ['portrait', 'studio'] },
            { file: 'L1000539.jpg', tags: ['landscape', 'mountains'] },
            { file: 'L1000540.jpg', tags: ['abstract', 'texture'] },
            { file: 'L1000700.jpg', tags: ['travel', 'urban'] },
            { file: 'L1000804.jpg', tags: ['minimal', 'clean'] },
            { file: 'L1001430.jpg', tags: ['documentary', 'people'] },
            { file: 'L1001747.jpg', tags: ['black-and-white', 'mood'] },
            { file: 'L1001923.jpg', tags: ['candid', 'street'] },
            { file: 'L1001949.jpg', tags: ['architecture', 'modern'] },
            { file: 'L1002140.jpg', tags: ['portrait', 'natural-light'] },
            { file: 'L1002356.jpg', tags: ['landscape', 'sunset'] },
            { file: 'L1002589.jpg', tags: ['urban', 'geometry'] },
            { file: 'L1002627.jpg', tags: ['travel', 'culture'] },
            { file: 'L1002712.jpg', tags: ['street', 'shadows'] },
            { file: 'L1002810.jpg', tags: ['nature', 'closeup'] },
            { file: 'L1002827.jpg', tags: ['minimal', 'abstract'] },
            { file: 'L1003052.jpg', tags: ['documentary', 'story'] },
            { file: 'L1003064.jpg', tags: ['portrait', 'environmental'] },
            { file: 'L1003657.jpg', tags: ['architecture', 'lines'] },
            { file: 'L1011333.jpg', tags: ['night', 'city'] },
            { file: 'L1011469.jpg', tags: ['candid', 'moment'] },
            { file: 'L1011524.jpg', tags: ['landscape', 'wide'] },
            { file: 'L1011524-2.jpg', tags: ['landscape', 'edit'] },
            { file: 'L1011561.jpg', tags: ['street', 'color'] },
            { file: 'L1011565.jpg', tags: ['urban', 'pattern'] },
            { file: 'L1011590.jpg', tags: ['minimal', 'space'] },
            { file: 'L1013229.jpg', tags: ['portrait', 'mood'] },
            { file: 'L1013636.jpg', tags: ['travel', 'adventure'] },
            { file: 'L1014406.jpg', tags: ['documentary', 'life'] },
            { file: 'L1020015.jpg', tags: ['nature', 'light'] },
            { file: 'L1030640.jpg', tags: ['architecture', 'detail'] },
            { file: 'L1031048.jpg', tags: ['street', 'people'] },
            { file: 'L1033116.jpg', tags: ['abstract', 'form'] },
            { file: 'L1034512.jpg', tags: ['candid', 'emotion'] },
            { file: 'L1035268-Enhanced-NR.jpg', tags: ['night', 'stars'] },
            { file: 'L1037449.jpg', tags: ['landscape', 'dramatic'] },
            { file: 'L1037643-Enhanced-NR-2.jpg', tags: ['night', 'long-exposure'] },
            { file: 'L1037887.jpg', tags: ['urban', 'texture'] },
            { file: 'L1038631.jpg', tags: ['portrait', 'artistic'] },
            { file: 'L1038688.jpg', tags: ['minimal', 'composition'] },
            { file: 'L1040668.jpg', tags: ['travel', 'explore'] },
            { file: 'L1041164.jpg', tags: ['street', 'quiet'] },
            { file: 'L1050083.jpg', tags: ['nature', 'green'] },
            { file: 'L1050361.jpg', tags: ['architecture', 'urban'] },
            { file: 'L1050470.jpg', tags: ['documentary', 'raw'] },
            { file: 'L1050503.jpg', tags: ['landscape', 'peaceful'] },
            { file: 'L1050672.jpg', tags: ['candid', 'natural'] },
            { file: 'L1050941.jpg', tags: ['abstract', 'color'] },
            { file: 'L1051097.jpg', tags: ['portrait', 'intimate'] },
            { file: 'L1060664.jpg', tags: ['minimal', 'negative-space'] },
            { file: 'L1120906.jpg', tags: ['travel', 'memory'] },
        ];

        // Gallery state
        let selectedImageIndex = 0;
        let galleryScrollOffset = 0; // Offset in pixels for smooth scrolling
        const loadedImages = new Map(); // Cache for loaded Image objects

        // Load images
        function loadGalleryImages() {
            galleryImages.forEach((imgData, index) => {
                const img = new Image();
                img.onload = () => {
                    loadedImages.set(index, img);
                };
                img.onerror = () => {
                    console.warn(`Failed to load: ${imgData.file}`);
                };
                img.src = GALLERY_PATH + imgData.file;
            });
        }

        // Calculate image width based on height (maintaining aspect ratio, default 3:2)
        function getImageWidth(index) {
            const img = loadedImages.get(index);
            if (img && img.naturalWidth && img.naturalHeight) {
                return (GALLERY_HEIGHT / img.naturalHeight) * img.naturalWidth;
            }
            return GALLERY_HEIGHT * 1.5; // Default 3:2 aspect ratio
        }

        // Get the X position where an image should be drawn
        function getImageXPosition(index) {
            let x = 0;
            for (let i = 0; i < index; i++) {
                x += getImageWidth(i) + IMAGE_GAP;
            }
            return x;
        }

        // Get total width of all images
        function getTotalGalleryWidth() {
            let width = 0;
            for (let i = 0; i < galleryImages.length; i++) {
                width += getImageWidth(i) + IMAGE_GAP;
            }
            return width - IMAGE_GAP; // Remove last gap
        }

        // Calculate scroll offset to center selected image
        function getTargetScrollOffset() {
            const centerX = canvas.width / 2;
            let imageX = 0;
            for (let i = 0; i < selectedImageIndex; i++) {
                imageX += getImageWidth(i) + IMAGE_GAP;
            }
            const selectedWidth = getImageWidth(selectedImageIndex);
            const imageCenterX = imageX + selectedWidth / 2;
            return centerX - imageCenterX;
        }

        // Smoothly animate scroll offset
        function updateGalleryScroll() {
            const target = getTargetScrollOffset();
            const diff = target - galleryScrollOffset;
            galleryScrollOffset += diff * 0.15; // Smooth easing
        }

        // Draw the image gallery strip
        function drawGallery() {
            const y = canvas.height - GALLERY_HEIGHT - GALLERY_MARGIN;
            const centerX = canvas.width / 2;

            // Draw images
            let x = galleryScrollOffset;
            for (let i = 0; i < galleryImages.length; i++) {
                const imgWidth = getImageWidth(i);
                const img = loadedImages.get(i);

                // Only draw if visible
                if (x + imgWidth > 0 && x < canvas.width) {
                    if (img) {
                        // Draw the image
                        ctx.drawImage(img, x, y, imgWidth, GALLERY_HEIGHT);
                    } else {
                        // Placeholder while loading
                        ctx.fillStyle = 'rgba(40, 40, 45, 0.8)';
                        ctx.fillRect(x, y, imgWidth, GALLERY_HEIGHT);
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.font = '12px Courier New, monospace';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('loading...', x + imgWidth/2, y + GALLERY_HEIGHT/2);
                    }

                    // Draw selection box if this is the selected image
                    if (i === selectedImageIndex) {
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(
                            x - SELECTION_BOX_PADDING,
                            y - SELECTION_BOX_PADDING,
                            imgWidth + SELECTION_BOX_PADDING * 2,
                            GALLERY_HEIGHT + SELECTION_BOX_PADDING * 2
                        );
                    }
                }

                x += imgWidth + IMAGE_GAP;
            }
        }

        // Navigate gallery
        function navigateGallery(direction) {
            selectedImageIndex += direction;
            if (selectedImageIndex < 0) selectedImageIndex = 0;
            if (selectedImageIndex >= galleryImages.length) selectedImageIndex = galleryImages.length - 1;
            updateControlPointsFromSelectedImage();
        }

        // Update control points based on selected image's tags
        function updateControlPointsFromSelectedImage() {
            const imgData = galleryImages[selectedImageIndex];
            if (!imgData) return;

            // Clear existing control points
            controlPoints.length = 0;
            selectedPoints.clear();

            // Create control points for each tag
            imgData.tags.forEach((tag, i) => {
                const angle = (i / imgData.tags.length) * Math.PI * 2 - Math.PI / 2;
                const radius = 0.2;
                const centerX = 0.4;
                const centerY = 0.4;
                const xRatio = centerX + Math.cos(angle) * radius;
                const yRatio = centerY + Math.sin(angle) * radius;

                const point = new ControlPoint(xRatio, yRatio);
                point.label = tag;
                controlPoints.push(point);
            });
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') {
                navigateGallery(-1);
                e.preventDefault();
            } else if (e.key === 'ArrowRight') {
                navigateGallery(1);
                e.preventDefault();
            }
        });

        // Initialize gallery
        loadGalleryImages();
        // Initialize control points from first image after a short delay
        setTimeout(updateControlPointsFromSelectedImage, 100);

        // Selection circle in upper right
        const selectionCircle = {
            getRadius() {
                return Math.min(canvas.width, canvas.height) * 0.15;
            },
            getX() {
                return canvas.width - this.getRadius() - 40;
            },
            getY() {
                return this.getRadius() + 40;
            },
            contains(x, y) {
                const dx = x - this.getX();
                const dy = y - this.getY();
                return Math.sqrt(dx * dx + dy * dy) <= this.getRadius();
            },
            draw() {
                const x = this.getX();
                const y = this.getY();
                const r = this.getRadius();

                // Draw circle background
                ctx.fillStyle = 'rgba(20, 20, 25, 0.9)';
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Label
                const hasSelected = selectedPoints.size > 0;
                const labelY = y + r - 20;

                ctx.font = '12px Courier New, monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                if (hasSelected) {
                    // Draw button box around text
                    const textWidth = ctx.measureText('new gallery').width;
                    const padding = 8;
                    const boxWidth = textWidth + padding * 2;
                    const boxHeight = 20;

                    ctx.fillStyle = 'rgba(30, 30, 35, 0.9)';
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.lineWidth = 1.5;
                    ctx.fillRect(x - boxWidth/2, labelY - boxHeight/2, boxWidth, boxHeight);
                    ctx.strokeRect(x - boxWidth/2, labelY - boxHeight/2, boxWidth, boxHeight);

                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                } else {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                }

                ctx.fillText('new gallery', x, labelY);
            }
        };

        // Track which points are selected (inside the circle)
        const selectedPoints = new Set();

        // Particle system - free-floating particles affected by any tag
        const particles = [];
        const pendingParticles = [];

        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 0.08;
                this.vy = (Math.random() - 0.5) * 0.08;
                this.size = 37.5 + Math.random() * 75; // Spawn at 37.5 to 112.5
                this.growthRate = (Math.random() - 0.5) * 0.6; // Slower grow/shrink for longer life
                this.grey = Math.floor(Math.random() * 25); // Dark grey to almost black (0-25)
                this.dying = false; // Whether particle is fading out
                this.fadeIn = 0; // Fade in progress (0 to 1)
                this.fadeInSpeed = 0.002 + Math.random() * 0.003; // Very slow fade in
                this.hasBorder = Math.random() < 0.4; // 40% chance of having a border
                this.borderGrey = Math.min(255, this.grey + 20 + Math.random() * 15); // Slightly lighter
            }

            update() {
                // Affected by all control points
                for (const point of controlPoints) {
                    const dx = point.x - this.x;
                    const dy = point.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 200 && dist > 0) {
                        // Stronger force, especially when close
                        const force = 0.8 / (dist * 0.05);
                        // Push away when close, slight pull when far
                        const pushPull = dist < 80 ? -1 : 0.15;
                        this.vx += (dx / dist) * force * pushPull;
                        this.vy += (dy / dist) * force * pushPull;
                    }
                }

                // Heavy damping - less movement
                this.vx *= 0.96;
                this.vy *= 0.96;

                // Very gentle random drift
                this.vx += (Math.random() - 0.5) * 0.008;
                this.vy += (Math.random() - 0.5) * 0.008;

                this.x += this.vx;
                this.y += this.vy;

                // Soft boundary - nudge back if going off screen
                if (this.x < 0) this.vx += 0.3;
                if (this.x > canvas.width) this.vx -= 0.3;
                if (this.y < 0) this.vy += 0.3;
                if (this.y > canvas.height) this.vy -= 0.3;

                // Fade in slowly
                if (this.fadeIn < 1) {
                    this.fadeIn += this.fadeInSpeed;
                    if (this.fadeIn > 1) this.fadeIn = 1;
                }

                // Size changes
                if (!this.dying) {
                    // Randomly adjust growth rate for organic feel
                    this.growthRate += (Math.random() - 0.5) * 0.15;
                    this.growthRate = Math.max(-0.9, Math.min(0.9, this.growthRate));
                    this.size += this.growthRate;

                    // Check for death conditions
                    if (this.size > 300) {
                        this.dying = true;
                        this.growthRate = 0.45 + Math.random() * 0.45; // Keep growing while dying
                    } else if (this.size < 75) {
                        this.dying = true;
                        this.growthRate = -0.3 - Math.random() * 0.3; // Keep shrinking while dying
                    }
                } else {
                    // Continue growing/shrinking while fading
                    this.size += this.growthRate;

                    // Dead when grown too big or shrunk to nothing
                    if (this.size > 450 || this.size <= 0) {
                        return false;
                    }
                }

                return true;
            }

            draw() {
                let alpha = 0.5;

                if (this.dying) {
                    if (this.growthRate > 0) {
                        // Growing and dying - fade based on size from 300 to 450
                        alpha = 0.5 * (1 - (this.size - 300) / 150);
                    } else {
                        // Shrinking and dying - fade based on size from 75 to 0
                        alpha = 0.5 * (this.size / 75);
                    }
                }

                // Apply fade in
                alpha *= this.fadeIn;

                alpha = Math.max(0, Math.min(0.5, alpha));

                const g = this.grey;
                const radius = Math.max(1, this.size);

                // Fill
                ctx.fillStyle = `rgba(${g}, ${g}, ${g}, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.fill();

                // Thin border for some particles
                if (this.hasBorder) {
                    const bg = this.borderGrey;
                    ctx.strokeStyle = `rgba(${bg}, ${bg}, ${bg}, ${alpha * 0.4})`;
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }
            }
        }

        // Randomly spawn dust motes across the screen
        function spawnRandomParticles() {
            // Target many more particles on screen
            const targetCount = 250;
            const currentCount = particles.length + pendingParticles.length;

            // Spawn multiple particles per frame when below target
            if (currentCount < targetCount) {
                const spawnChance = Math.random();
                const numToSpawn = spawnChance < 0.3 ? 2 : (spawnChance < 0.7 ? 1 : 0);

                for (let i = 0; i < numToSpawn; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const delay = Math.floor(Math.random() * 20);
                    pendingParticles.push({ x, y, delay });
                }
            }
        }

        function updateAndDrawParticles() {
            // Spawn new random particles
            spawnRandomParticles();

            // Process pending particles
            for (let i = pendingParticles.length - 1; i >= 0; i--) {
                const pending = pendingParticles[i];
                pending.delay--;
                if (pending.delay <= 0) {
                    particles.push(new Particle(pending.x, pending.y));
                    pendingParticles.splice(i, 1);
                }
            }

            // Update and draw active particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.draw();
                if (!p.update()) {
                    particles.splice(i, 1);
                }
            }
        }

        // Generate a random vibrant color
        function randomColor() {
            const hue = Math.floor(Math.random() * 360);
            return {
                hue: hue,
                fill: `hsla(${hue}, 70%, 20%, 1)`,
                stroke: `hsla(${hue}, 70%, 55%, 0.8)`,
                text: `hsla(${hue}, 70%, 70%, 0.9)`,
                line: `hsla(${(hue + 180) % 360}, 60%, 50%, 0.6)` // Complementary color for lines
            };
        }

        class ControlPoint {
            constructor(xRatio, yRatio, label = 'tag') {
                this.xRatio = xRatio;
                this.yRatio = yRatio;
                this.x = canvas.width * xRatio;
                this.y = canvas.height * yRatio;
                this.selectedColor = null;
                this.label = label;
            }

            updatePosition() {
                this.x = canvas.width * this.xRatio;
                this.y = canvas.height * this.yRatio;
            }

            draw(isHovered, isSelected = false) {
                const w = HANDLE_WIDTH;
                const h = HANDLE_HEIGHT;

                ctx.fillStyle = '#111111';

                if (isSelected && this.selectedColor) {
                    // Selected style - dark fill, colored border
                    ctx.strokeStyle = this.selectedColor.stroke;
                    ctx.lineWidth = isHovered ? 2 : 1.5;
                } else {
                    ctx.strokeStyle = isHovered ? 'rgba(255, 255, 255, 0.8)' : 'rgba(255, 255, 255, 0.4)';
                    ctx.lineWidth = isHovered ? 2 : 1;
                }

                ctx.fillRect(this.x - w/2, this.y - h/2, w, h);
                ctx.strokeRect(this.x - w/2, this.y - h/2, w, h);

                ctx.fillStyle = (isSelected && this.selectedColor)
                    ? this.selectedColor.text
                    : (isHovered ? 'rgba(255, 255, 255, 0.9)' : 'rgba(255, 255, 255, 0.5)');
                ctx.font = '14px Courier New, monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.label || 'tag', this.x, this.y);
            }

            contains(mx, my) {
                const w = HANDLE_WIDTH;
                const h = HANDLE_HEIGHT;
                return mx >= this.x - w/2 && mx <= this.x + w/2 &&
                       my >= this.y - h/2 && my <= this.y + h/2;
            }

            setPosition(x, y) {
                this.x = x;
                this.y = y;
                this.xRatio = x / canvas.width;
                this.yRatio = y / canvas.height;
            }
        }

        // Control points will be populated from the selected image's tags
        const controlPoints = [];

        class Curve {
            constructor(pointIndices) {
                this.pointIndices = pointIndices;
                this.pulsePhase = Math.random() * Math.PI * 2;
                this.pulseSpeed = 0.01 + Math.random() * 0.01;
            }

            update() {
                this.pulsePhase += this.pulseSpeed;
            }

            draw() {
                // Skip curves that include any selected points
                const hasSelectedPoint = this.pointIndices.some(i => selectedPoints.has(controlPoints[i]));
                if (hasSelectedPoint) return;

                const pulse = Math.sin(this.pulsePhase) * 0.5 + 0.5;
                const opacity = 0.15 + pulse * 0.65;
                const pts = this.pointIndices.map(i => controlPoints[i]);

                if (pts.length < 2) return;

                ctx.strokeStyle = `rgba(240, 240, 235, ${opacity})`;
                ctx.lineWidth = 1;
                ctx.lineCap = 'round';
                ctx.beginPath();

                if (pts.length === 2) {
                    ctx.moveTo(pts[0].x, pts[0].y);
                    ctx.lineTo(pts[1].x, pts[1].y);
                } else if (pts.length === 3) {
                    ctx.moveTo(pts[0].x, pts[0].y);
                    ctx.quadraticCurveTo(pts[1].x, pts[1].y, pts[2].x, pts[2].y);
                } else if (pts.length === 4) {
                    ctx.moveTo(pts[0].x, pts[0].y);
                    ctx.bezierCurveTo(pts[1].x, pts[1].y, pts[2].x, pts[2].y, pts[3].x, pts[3].y);
                } else {
                    ctx.moveTo(pts[0].x, pts[0].y);
                    for (let i = 0; i < pts.length - 1; i++) {
                        const p0 = pts[Math.max(0, i - 1)];
                        const p1 = pts[i];
                        const p2 = pts[Math.min(pts.length - 1, i + 1)];
                        const p3 = pts[Math.min(pts.length - 1, i + 2)];

                        const cp1x = p1.x + (p2.x - p0.x) / 6;
                        const cp1y = p1.y + (p2.y - p0.y) / 6;
                        const cp2x = p2.x - (p3.x - p1.x) / 6;
                        const cp2y = p2.y - (p3.y - p1.y) / 6;

                        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
                    }
                }
                ctx.stroke();
            }
        }

        const baseCurves = [
            new Curve([0, 1, 2]),
            new Curve([0, 3, 4, 2]),
            new Curve([3, 4, 5]),
            new Curve([1, 4, 6]),
            new Curve([0, 3, 6]),
            new Curve([2, 5, 6]),
            new Curve([1, 2, 5]),
            new Curve([0, 1, 4, 5]),
            new Curve([3, 1, 5, 6]),
            new Curve([0, 4, 2]),
            new Curve([3, 6, 5, 2]),
            new Curve([1, 3, 4, 5, 2]),
        ];

        // Offscreen dummy points for creating curves when few points remain
        function getDummyPoints() {
            return [
                { x: -100, y: canvas.height * 0.3 },
                { x: -100, y: canvas.height * 0.7 },
                { x: canvas.width + 100, y: canvas.height * 0.5 },
                { x: canvas.width * 0.5, y: -100 },
                { x: canvas.width * 0.3, y: canvas.height + 100 },
                { x: canvas.width * 0.7, y: canvas.height + 100 },
            ];
        }

        // Draw dynamic curves for unselected points - ensures each has multiple connections
        function drawDynamicCurves() {
            const unselected = controlPoints.filter(p => !selectedPoints.has(p));
            const time = Date.now() * 0.001;

            if (unselected.length === 0) return;

            ctx.lineWidth = 1;
            ctx.lineCap = 'round';

            // Always draw curves between all pairs of unselected points
            for (let i = 0; i < unselected.length; i++) {
                for (let j = i + 1; j < unselected.length; j++) {
                    const p1 = unselected[i];
                    const p2 = unselected[j];

                    // Draw multiple curved lines between each pair
                    for (let c = 0; c < 2; c++) {
                        const phase = time * (0.01 + c * 0.007) + i * 0.5 + j * 0.3;
                        const pulse = Math.sin(phase) * 0.5 + 0.5;
                        const opacity = 0.15 + pulse * 0.65;

                        const midX = (p1.x + p2.x) / 2;
                        const midY = (p1.y + p2.y) / 2;
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const perpX = -dy;
                        const perpY = dx;
                        const len = Math.sqrt(perpX * perpX + perpY * perpY) || 1;
                        const offset = (c === 0 ? 1 : -1) * (40 + c * 30);

                        const ctrlX = midX + (perpX / len) * offset;
                        const ctrlY = midY + (perpY / len) * offset;

                        ctx.strokeStyle = `rgba(240, 240, 235, ${opacity})`;
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.quadraticCurveTo(ctrlX, ctrlY, p2.x, p2.y);
                        ctx.stroke();
                    }
                }
            }

            // Draw curves to/from offscreen dummy points for each unselected point
            const dummies = getDummyPoints();
            unselected.forEach((p, pIdx) => {
                // Each point connects to 2-3 dummy points
                const numDummyConnections = 3;
                for (let d = 0; d < numDummyConnections; d++) {
                    const dummyIdx = (pIdx + d) % dummies.length;
                    const dummy = dummies[dummyIdx];

                    const phase = time * (0.008 + d * 0.004) + pIdx * 0.8 + d * 1.2;
                    const pulse = Math.sin(phase) * 0.5 + 0.5;
                    const opacity = 0.15 + pulse * 0.5;

                    // Use another dummy or midpoint as curve control
                    const ctrlDummy = dummies[(dummyIdx + 3) % dummies.length];
                    const ctrlX = (p.x + dummy.x + ctrlDummy.x) / 3;
                    const ctrlY = (p.y + dummy.y + ctrlDummy.y) / 3;

                    ctx.strokeStyle = `rgba(240, 240, 235, ${opacity})`;
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.quadraticCurveTo(ctrlX, ctrlY, dummy.x, dummy.y);
                    ctx.stroke();
                }
            });

            // If only one point, add self-connecting arcs
            if (unselected.length === 1) {
                const p = unselected[0];
                for (let i = 0; i < 3; i++) {
                    const phase = time * 0.5 + i * 0.7;
                    const pulse = Math.sin(phase) * 0.5 + 0.5;
                    const opacity = 0.15 + pulse * 0.65;

                    ctx.strokeStyle = `rgba(240, 240, 235, ${opacity})`;
                    const arcRadius = 40 + i * 25;
                    const rotation = i * Math.PI / 3;

                    ctx.beginPath();
                    ctx.arc(
                        p.x + Math.cos(rotation) * arcRadius * 0.3,
                        p.y + Math.sin(rotation) * arcRadius * 0.3 - arcRadius,
                        arcRadius,
                        0.2 * Math.PI + rotation * 0.3,
                        0.8 * Math.PI + rotation * 0.3
                    );
                    ctx.stroke();
                }
            }

            // Also draw original base curves when we have enough points
            if (unselected.length >= 4) {
                baseCurves.forEach(curve => {
                    curve.update();
                    curve.draw();
                });
            }
        }

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            controlPoints.forEach(p => p.updatePosition());
        });

        canvas.addEventListener('mousedown', (e) => {
            const mx = e.clientX;
            const my = e.clientY;

            for (const point of controlPoints) {
                if (point.contains(mx, my)) {
                    draggedPoint = point;
                    canvas.style.cursor = 'grabbing';
                    break;
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const mx = e.clientX;
            const my = e.clientY;

            if (draggedPoint) {
                draggedPoint.setPosition(mx, my);
            } else {
                hoveredPoint = null;
                for (const point of controlPoints) {
                    if (point.contains(mx, my)) {
                        hoveredPoint = point;
                        canvas.style.cursor = 'grab';
                        break;
                    }
                }
                if (!hoveredPoint) {
                    canvas.style.cursor = 'default';
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            draggedPoint = null;
            canvas.style.cursor = hoveredPoint ? 'grab' : 'default';
        });

        canvas.addEventListener('mouseleave', () => {
            draggedPoint = null;
            hoveredPoint = null;
            canvas.style.cursor = 'default';
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mx = touch.clientX;
            const my = touch.clientY;

            for (const point of controlPoints) {
                if (point.contains(mx, my)) {
                    draggedPoint = point;
                    break;
                }
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (draggedPoint) {
                const touch = e.touches[0];
                draggedPoint.setPosition(touch.clientX, touch.clientY);
            }
        }, { passive: false });

        canvas.addEventListener('touchend', () => {
            draggedPoint = null;
        });

        // Get dummy points for selected area - 270 degree arc above and to the right of circle
        // All points positioned offscreen
        function getSelectedDummyPoints() {
            const cx = selectionCircle.getX();
            const cy = selectionCircle.getY();

            // Position dummy points well offscreen
            return [
                { x: cx - 200, y: -150 },           // top-left, off top edge
                { x: cx, y: -150 },                  // top, off top edge
                { x: cx + 200, y: -150 },           // top-right, off top edge
                { x: canvas.width + 150, y: cy - 200 },  // right, off right edge
                { x: canvas.width + 150, y: cy },        // right, off right edge
                { x: canvas.width + 150, y: cy + 200 },  // right-bottom, off right edge
                { x: cx + 200, y: canvas.height + 150 }, // bottom, off bottom edge
            ];
        }

        // Draw curved connections between selected points
        function drawSelectedConnections() {
            const selected = Array.from(selectedPoints);
            if (selected.length < 1) return;

            const time = Date.now() * 0.001;
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';

            const cx = selectionCircle.getX();
            const cy = selectionCircle.getY();

            // Draw curves between selected points
            if (selected.length === 1) {
                // Single point - draw a self-connecting arc
                const p = selected[0];
                ctx.strokeStyle = p.selectedColor ? p.selectedColor.line : 'rgba(50, 100, 200, 0.6)';
                const arcRadius = 30;
                ctx.beginPath();
                ctx.arc(p.x, p.y - arcRadius, arcRadius, 0.3 * Math.PI, 0.7 * Math.PI);
                ctx.stroke();
            } else {
                // Multiple points - draw curved lines between all pairs
                for (let i = 0; i < selected.length; i++) {
                    for (let j = i + 1; j < selected.length; j++) {
                        const p1 = selected[i];
                        const p2 = selected[j];

                        const midX = (p1.x + p2.x) / 2;
                        const midY = (p1.y + p2.y) / 2;

                        // Use perpendicular offset for more dramatic curves
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const perpX = -dy;
                        const perpY = dx;
                        const len = Math.sqrt(perpX * perpX + perpY * perpY) || 1;

                        const curveDirection = (i + j) % 2 === 0 ? 1 : -1;
                        const curveAmount = 60 + (i + j) * 20;

                        const ctrlX = midX + (perpX / len) * curveAmount * curveDirection;
                        const ctrlY = midY + (perpY / len) * curveAmount * curveDirection;

                        // Use line color from first point
                        ctx.strokeStyle = p1.selectedColor ? p1.selectedColor.line : 'rgba(50, 100, 200, 0.6)';
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.quadraticCurveTo(ctrlX, ctrlY, p2.x, p2.y);
                        ctx.stroke();
                    }
                }
            }

            // Draw curves to offscreen dummy points
            const dummies = getSelectedDummyPoints();
            selected.forEach((p, pIdx) => {
                // Each selected point connects to 2-3 dummy points
                const numConnections = 3;
                for (let d = 0; d < numConnections; d++) {
                    const dummyIdx = (pIdx * 2 + d) % dummies.length;
                    const dummy = dummies[dummyIdx];

                    const phase = time * (0.01 + d * 0.005) + pIdx * 0.6 + d * 0.9;
                    const pulse = Math.sin(phase) * 0.5 + 0.5;
                    const opacity = 0.3 + pulse * 0.4;

                    // Curve control point - much more curved
                    const midX = (p.x + dummy.x) / 2;
                    const midY = (p.y + dummy.y) / 2;

                    // Calculate perpendicular offset for more dramatic curves
                    const dx = dummy.x - p.x;
                    const dy = dummy.y - p.y;
                    const perpX = -dy;
                    const perpY = dx;
                    const len = Math.sqrt(perpX * perpX + perpY * perpY) || 1;

                    // Alternate curve direction and use larger offsets
                    const curveDirection = (pIdx + d) % 2 === 0 ? 1 : -1;
                    const curveAmount = 120 + d * 60;

                    const ctrlX = midX + (perpX / len) * curveAmount * curveDirection;
                    const ctrlY = midY + (perpY / len) * curveAmount * curveDirection;

                    // Use line color from point with pulsing opacity
                    if (p.selectedColor) {
                        const hue = (p.selectedColor.hue + 180) % 360;
                        ctx.strokeStyle = `hsla(${hue}, 60%, 50%, ${opacity})`;
                    } else {
                        ctx.strokeStyle = `rgba(50, 100, 200, ${opacity})`;
                    }
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.quadraticCurveTo(ctrlX, ctrlY, dummy.x, dummy.y);
                    ctx.stroke();
                }
            });
        }

        // Update which points are selected based on position
        function updateSelectedPoints() {
            for (const point of controlPoints) {
                if (selectionCircle.contains(point.x, point.y)) {
                    if (!selectedPoints.has(point)) {
                        // Entering circle - assign random color
                        point.selectedColor = randomColor();
                        selectedPoints.add(point);
                    }
                } else {
                    if (selectedPoints.has(point)) {
                        // Leaving circle - clear color
                        point.selectedColor = null;
                        selectedPoints.delete(point);
                    }
                }
            }
        }

        function animate() {
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update selection state
            updateSelectedPoints();

            // Update gallery scroll position
            updateGalleryScroll();

            // Draw particles behind everything
            updateAndDrawParticles();

            // Draw selection circle
            selectionCircle.draw();

            // Draw dynamic curves for unselected points
            drawDynamicCurves();

            // Draw connections between selected points
            drawSelectedConnections();

            // Draw control points on top
            for (const point of controlPoints) {
                const isSelected = selectedPoints.has(point);
                point.draw(point === hoveredPoint || point === draggedPoint, isSelected);
            }

            // Draw gallery at the bottom
            drawGallery();

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
